# app.py
import openai
import streamlit as st
import gspread
import requests
import hashlib
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib import font_manager as fm, rcParams
from datetime import datetime
import os
from oauth2client.service_account import ServiceAccountCredentials
from itertools import combinations

openai.api_key = st.secrets["openai"]["api_key"]

# Ìè∞Ìä∏ ÏÑ§Ï†ï
font_path = os.path.join("fonts", "NanumGothic.ttf")
fm.fontManager.addfont(font_path)
prop = fm.FontProperties(fname=font_path)
font_name = prop.get_name()
rcParams["font.family"] = font_name
plt.rc('axes', unicode_minus=False)

st.set_page_config("üìà Ïú†ÌäúÎ∏å Ï°∞ÌöåÏàò Î∂ÑÏÑùÍ∏∞", layout="centered")

st.title("üìà Ïú†ÌäúÎ∏å Ï°∞ÌöåÏàò Î∂ÑÏÑùÍ∏∞")
st.subheader("ÌïôÏÉùÏö© Î°úÍ∑∏Ïù∏/ÌöåÏõêÍ∞ÄÏûÖ")


# --- 1) ÏÑ∏ÏÖò ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî ---
if "logged_in" not in st.session_state:
    st.session_state["logged_in"] = False
if "user" not in st.session_state:
    st.session_state["user"] = None
if "step" not in st.session_state:
    st.session_state["step"] = 1  # ÏàòÏóÖ Îã®Í≥Ñ


# Íµ¨Í∏Ä ÏãúÌä∏ Ïù∏Ï¶ù
scope = ["https://spreadsheets.google.com/feeds","https://www.googleapis.com/auth/drive"]
creds_dict = st.secrets["gcp_service_account"]
creds = ServiceAccountCredentials.from_json_keyfile_dict(creds_dict, scope)
gc = gspread.authorize(creds)

yt_conf  = st.secrets["sheets"]["youtube"]  # Ï°∞Ìöå Í∏∞Î°ùÏö© ÏãúÌä∏
usr_conf = st.secrets["sheets"]["users"]    # ÌöåÏõêDBÏö© ÏãúÌä∏
YOUTUBE_API_KEY = st.secrets["youtube"]["api_key"]

yt_wb     = gc.open_by_key(yt_conf["spreadsheet_id"])
yt_sheet  = yt_wb.worksheet(yt_conf["sheet_name"])
usr_wb    = gc.open_by_key(usr_conf["spreadsheet_id"])
usr_sheet = usr_wb.worksheet(usr_conf["sheet_name"])

# Ìï¥Ïãú Ìï®Ïàò
def hash_password(pw: str) -> str:
    if not isinstance(pw, str) or pw == "":
        return ""
    return hashlib.sha256(pw.encode("utf-8")).hexdigest()


# ==== ÌöåÏõêÍ∞ÄÏûÖ UI ====
def signup_ui():
    st.subheader("ÌöåÏõêÍ∞ÄÏûÖ")
    sid = st.text_input("ÌïôÎ≤à", key="signup_sid")
    name = st.text_input("Ïù¥Î¶Ñ", key="signup_name")
    pwd = st.text_input("ÎπÑÎ∞ÄÎ≤àÌò∏", type="password", key="signup_pwd")
    if st.button("ÌöåÏõêÍ∞ÄÏûÖ"):
        if not sid or not name or not pwd:
            st.error("ÌïôÎ≤à, Ïù¥Î¶Ñ, ÎπÑÎ∞ÄÎ≤àÌò∏Î•º Î™®Îëê ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.")
            return
        pw_hash = hash_password(pwd)
        if pw_hash == "":
            st.error("ÎπÑÎ∞ÄÎ≤àÌò∏ Ï≤òÎ¶¨Ïóê Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.")
            return
        rows = usr_sheet.get_all_records()
        if any(r["ÌïôÎ≤à"] == sid for r in rows):
            st.error("Ïù¥ÎØ∏ Îì±Î°ùÎêú ÌïôÎ≤àÏûÖÎãàÎã§.")
        else:
            usr_sheet.append_row([sid, name, pw_hash])
            st.success(f"{name}Îãò, ÌöåÏõêÍ∞ÄÏûÖÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!")

# Î°úÍ∑∏Ïù∏ UI
def login_ui():
    st.header("üîê Î°úÍ∑∏Ïù∏")
    rows = usr_sheet.get_all_records()
    sid = st.text_input("ÌïôÎ≤à", key="login_sid")
    pwd = st.text_input("ÎπÑÎ∞ÄÎ≤àÌò∏", type="password", key="login_pwd")

    if st.button("Î°úÍ∑∏Ïù∏"):
        # Ïà´ÏûêÎ°ú ÎπÑÍµêÌïòÍ≥† Ïã∂ÏúºÎ©¥:
        try:
            sid_int = int(sid)
        except ValueError:
            st.error("ÌïôÎ≤àÏùÄ Ïà´ÏûêÏó¨Ïïº Ìï©ÎãàÎã§.")
            return

        # Ïù¥ÎØ∏ Ìï¥ÏãúÎêú ÎπÑÎ∞ÄÎ≤àÌò∏
        pw_hash = hash_password(pwd)
        # ÌïôÎ≤àÏúºÎ°ú ÌöåÏõê Ï∞æÍ∏∞
        user = next((r for r in rows if str(r["ÌïôÎ≤à"]) == sid), None)
        if not user:
            st.error("‚ùå Îì±Î°ùÎêòÏßÄ ÏïäÏùÄ ÌïôÎ≤àÏûÖÎãàÎã§.")
            return

        # ÎπÑÎ∞ÄÎ≤àÌò∏ Ìï¥Ïãú ÎπÑÍµê
        if user.get("ÏïîÌò∏(Ìï¥Ïãú)") != pw_hash:
            st.error("‚ùå ÎπÑÎ∞ÄÎ≤àÌò∏Í∞Ä ÏùºÏπòÌïòÏßÄ ÏïäÏäµÎãàÎã§.")
            return

        # Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ!
        st.session_state["logged_in"] = True
        st.session_state["user"] = user
        st.success(f"üéâ ÌôòÏòÅÌï©ÎãàÎã§, {user['Ïù¥Î¶Ñ']}Îãò!")
        st.rerun()
        return

# Ïú†ÌäúÎ∏å ÏòÅÏÉÅ ID Ï∂îÏ∂ú
def extract_video_id(url):
    import re
    m = re.search(r"(?:v=|youtu\.be/)([A-Za-z0-9_-]{11})", url)
    return m.group(1) if m else None

# Ï°∞ÌöåÏàò API Ìò∏Ï∂ú
def get_video_statistics(video_id):
    import requests
    url = (
        f"https://www.googleapis.com/youtube/v3/videos"
        f"?part=statistics&id={video_id}&key={YOUTUBE_API_KEY}"
    )
    r = requests.get(url)
    st.write("üîó ÏöîÏ≤≠ URL:", url)
    st.write("üì£ HTTP Status:", r.status_code)
    try:
        data = r.json()
        st.write("üìù ÏùëÎãµ JSON:", data)
    except Exception as e:
        st.write("‚ö†Ô∏è JSON ÌååÏã± Ïò§Î•ò:", e)
        return None

    items = data.get("items")
    if items:
        stats = items[0]["statistics"]
        return {
            "viewCount": int(stats.get("viewCount", 0)),
            "likeCount": int(stats.get("likeCount", 0)),
            "commentCount": int(stats.get("commentCount", 0)),
        }
    return None

def summarize_discussion(text):
    resp = openai.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[
            {"role":"system", "content":"ÎãπÏã†ÏùÄ ÌõåÎ•≠Ìïú ÏöîÏïΩÍ∞ÄÏûÖÎãàÎã§."},
            {"role":"user", "content":f"Îã§Ïùå ÌÜ†Ïùò ÎÇ¥Ïö©ÏùÑ ÏßßÍ≥† ÍπîÎÅîÌïòÍ≤å ÏöîÏïΩÌï¥Ï£ºÏÑ∏Ïöî:\n\n{text}"}
        ],
        temperature=0.3,
        max_tokens=300
    )
    return resp.choices[0].message.content.strip()

# --- 8) Î©îÏù∏ ÌôîÎ©¥(Î°úÍ∑∏Ïù∏ ÌõÑ) ---
def main_ui():
    user = st.session_state["user"]
    sid = str(user["ÌïôÎ≤à"]) 
    st.sidebar.success(f"üëã {user['Ïù¥Î¶Ñ']}Îãò, Î∞òÍ∞ëÏäµÎãàÎã§!")
    st.write("Î°úÍ∑∏Ïù∏Ïóê ÏÑ±Í≥µÌñàÏäµÎãàÎã§! Ïù¥Í≥≥ÏóêÏÑú Ïú†ÌäúÎ∏å Î∂ÑÏÑù Í∏∞Îä•ÏùÑ ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî.")
    col1,col2=st.sidebar.columns(2)
    if col1.button('‚óÄ Ïù¥Ï†Ñ Îã®Í≥Ñ') and st.session_state['step']>1:
        st.session_state['step']-=1
        st.rerun()
    if col2.button('Îã§Ïùå Îã®Í≥Ñ ‚ñ∂') and st.session_state['step']<4:
        st.session_state['step']+=1
        st.rerun()
    step=st.session_state['step']
    st.info(f"ÌòÑÏû¨  {step}Ï∞®Ïãú ÌôúÎèô Ï§ë")

    
    all_records = yt_sheet.get_all_records()
    records = [r for r in all_records if str(r["ÌïôÎ≤à"]) == sid]

    if step==1:
        st.header("1Ô∏è‚É£ Ïú†ÌäúÎ∏å Ï°∞ÌöåÏàò Í∏∞Î°ùÌïòÍ∏∞")
        yt_url = st.text_input("Ïú†ÌäúÎ∏å ÎßÅÌÅ¨Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî")
        if st.button("Ï°∞ÌöåÏàò Í∏∞Î°ù"):
            vid = extract_video_id(yt_url)
            if not vid:
                st.error("‚õî Ïú†Ìö®Ìïú Ïú†ÌäúÎ∏å ÎßÅÌÅ¨Í∞Ä ÏïÑÎãôÎãàÎã§.")
            else:
                stats = get_video_statistics(vid)
                if not stats:
                    st.error("üò¢ ÏòÅÏÉÅ Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.")
                else:
                    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    # ['ÌïôÎ≤à','video_id','timestamp','viewCount','likeCount','commentCount']
                    yt_sheet.append_row([
                        user["ÌïôÎ≤à"], vid, timestamp,
                        stats["viewCount"], stats["likeCount"], stats["commentCount"]
                    ])
                    st.success("‚úÖ Í∏∞Î°ù ÏôÑÎ£å")

    elif step==2:
        st.header("2Ô∏è‚É£ Ïú†ÌäúÎ∏å Ï°∞ÌöåÏàò Î∂ÑÏÑùÌïòÍ∏∞")
        if not records:
            st.info("ÎÇ¥ Í∏∞Î°ùÏù¥ ÏïÑÏßÅ ÏóÜÏäµÎãàÎã§. Î®ºÏ†Ä '1Ô∏è‚É£ Ï°∞ÌöåÏàò Í∏∞Î°ùÌïòÍ∏∞'Î°ú Í∏∞Î°ùÌïòÏÑ∏Ïöî.")
            return
        # Í∑∏ÎûòÌîÑ Î≥¥Í∏∞ Î≤ÑÌäº
        if st.button("Í∑∏ÎûòÌîÑ Î≥¥Í∏∞"):
        # (1) Ï†ÑÏ≤òÎ¶¨
            df = pd.DataFrame(records)
            df["timestamp"] = pd.to_datetime(df["timestamp"], infer_datetime_format=True)
            df["viewCount"] = df["viewCount"].astype(int)
            df = df.sort_values("timestamp").reset_index(drop=True)

            base = df["timestamp"].min()
            x_all = (df["timestamp"] - base).dt.total_seconds().values
            y_all = df["viewCount"].values

            # 2) Í∞ÄÎä•Ìïú 3Ï†ê Ï°∞Ìï© Ï§ë 'a>0' & f' >0 on interval' Ï°∞Í±¥ ÎßåÏ°± Ï°∞Ìï© Ï∞æÍ∏∞
            candidates = []
            for i, j, k in combinations(range(len(df)), 3):
                xi = x_all[[i, j, k]]
                yi = y_all[[i, j, k]]
                a_coef, b_coef, _ = np.polyfit(xi, yi, 2)

                # concave up
                if a_coef <= 0:
                    continue

                # derivative positive at i and k
                deriv_i = 2 * a_coef * xi[0] + b_coef
                deriv_k = 2 * a_coef * xi[2] + b_coef
                if deriv_i <= 0 or deriv_k <= 0:
                    continue

                # fit error
                y_pred = a_coef*xi**2 + b_coef*xi + _
                mse = np.mean((yi - y_pred)**2)
                candidates.append((mse, (i, j, k)))

            if candidates:
                # best triple by lowest MSE
                _, (i1, i2, i3) = min(candidates, key=lambda x: x[0])
                synthetic = None
                sel_idx = [i1, i2, i3]
            else:
                # fallback: last two + synthetic
                i1, i2 = len(df)-2, len(df)-1
                dt = x_all[i2] - x_all[i1]
                slope_last = (y_all[i2] - y_all[i1]) / dt
                # amplify slope to enforce accel>0
                slope3 = slope_last * 1.2
                t3 = x_all[i2] + dt
                y3 = y_all[i2] + slope3 * dt
                ts3 = base + pd.to_timedelta(t3, unit="s")
                synthetic = {"timestamp": ts3, "viewCount": int(y3)}
                sel_idx = [i1, i2, "synthetic"]

            # 3) ÏÑ†ÌÉùÎêú Ï†ê DataFrame
            pts = []
            for idx in sel_idx:
                if idx == "synthetic":
                    pts.append(synthetic)
                else:
                    pts.append({
                        "timestamp": df.loc[idx, "timestamp"],
                        "viewCount": int(df.loc[idx, "viewCount"])
                    })
            sel_df = pd.DataFrame(pts)

            # 4) regression
            x_sel = (sel_df["timestamp"] - base).dt.total_seconds().values
            y_sel = sel_df["viewCount"].values
            a, b, c = np.polyfit(x_sel, y_sel, 2)

            st.markdown(f"**ÌöåÍ∑ÄÏãù:** `y = {a:.3e}¬∑x¬≤ + {b:.3e}¬∑x + {c:.3e}`")

            # 5) ÏòàÏ∏°
            roots = np.roots([a, b, c - 1_000_000])
            rr = [r.real for r in roots if abs(r.imag) < 1e-6]
            if rr:
                t_pred = max(rr)
                dt_pred = base + pd.to_timedelta(t_pred, unit="s")
                st.write(f"‚ñ∂Ô∏è Ï°∞ÌöåÏàò **1,000,000Ìöå** ÎèåÌåå ÏòàÏÉÅ ÏãúÏ†ê: **{dt_pred}**")

            # 6) ÏãúÍ∞ÅÌôî
            fig, ax = plt.subplots(figsize=(8,4))
            # Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞
            ax.scatter(df["timestamp"], y_all, color="skyblue", alpha=0.6, s=20, label="Ï†ÑÏ≤¥ Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞")
            # Ìè¨Î¨ºÏÑ† Í≥°ÏÑ†
            ts_curve = np.linspace(x_all.min(), x_all.max(), 300)
            ax.plot(
                base + pd.to_timedelta(ts_curve, unit="s"),
                a*ts_curve**2 + b*ts_curve + c,
                color="orange", lw=2, label="2Ï∞® ÌöåÍ∑ÄÍ≥°ÏÑ† (Ï†ÑÏ≤¥)"
            )
            # Ïã§Ï†ú ÏÑ†ÌÉù Ï†ê
            real_idxs = [idx for idx in sel_idx if idx != "synthetic"]
            ax.scatter(df.loc[real_idxs, "timestamp"], df.loc[real_idxs, "viewCount"],
                    color="green", s=80, label="ÏÑ†ÌÉùÎêú Ïã§Ï†ú Ï†ê")
            # synthetic Ï†ê
            if synthetic:
                ax.scatter(synthetic["timestamp"], synthetic["viewCount"],
                        color="red", s=100, label="Synthetic Ï†ê")

            # xÏ∂ï Ï†ÑÏ≤¥
            ax.set_xlim(df["timestamp"].min(), df["timestamp"].max())
            # yÏ∂ï
            y_min = min(y_all.min(), y_sel.min()) * 0.9
            y_max = max(y_all.max(), y_sel.max()) * 1.1
            ax.set_ylim(y_min, y_max)

            ax.set_xlabel("ÏãúÍ∞Ñ")
            ax.set_ylabel("Ï°∞ÌöåÏàò")
            ax.legend()
            plt.xticks(rotation=45)
            st.pyplot(fig)

    elif step==3:
        df = pd.DataFrame(records)
        df["timestamp"] = pd.to_datetime(df["timestamp"])
        df["viewCount"]  = df["viewCount"].astype(int)
        df = df.sort_values("timestamp").reset_index(drop=True)

        base = df["timestamp"].min()
        x = (df["timestamp"] - base).dt.total_seconds().values
        y = df["viewCount"].values

        # ÏãúÍ∞Ñ Í∏∞Î∞ò 2Ï∞® ÌöåÍ∑Ä Í≥ÑÏàò
        a, b, c = np.polyfit(x, y, 2)
        time_poly = np.poly1d([a, b, c])

        st.markdown(f"**ÏãúÍ∞Ñ Î™®Îç∏:**  $y_\\mathrm{{time}}=\\,{a:.3e}x^2 \\,+\\,{b:.3e}x\\,+\\,{c:.3e}$")

        # 2) Í¥ëÍ≥†ÎπÑ ÏûÖÎ†•
        budget = st.number_input("Ìà¨ÏûÖÌï† Í¥ëÍ≥†ÎπÑÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî (Ïõê)", min_value=0, step=1000, value=1000000)

        # Í¥ëÍ≥†ÎπÑ Ìö®Í≥º Í≥ÑÏàò(Œ≥)Îäî ÏÇ¨Ïö©Ïûê Ï†ïÏùò ÌòπÏùÄ Í≥ºÍ±∞ Îç∞Ïù¥ÌÑ∞Î°ú ÌöåÍ∑ÄÌï¥ÏÑú Ï∂îÏ†ï
        # Ïó¨Í∏∞ÏÑúÎäî Í∞ÑÎã®Ìûà Œ≥=0.5 Î°ú ÏÑ§Ï†ï (ÏõêÎãπ ‚àöÏòàÏÇ∞ 0.5Ìöå Ï¶ùÍ∞Ä)
        gamma = st.slider("Í¥ëÍ≥†ÎπÑ Ìö®Í≥ºÍ≥ÑÏàò Œ≥ ÏÑ§Ï†ï", min_value=0.0, max_value=5.0, value=0.5)

        # 3) ÌÜµÌï© ÏòàÏ∏°
        # - ÌòÑÏû¨ ÏãúÏ†ê(ÎßàÏßÄÎßâ Îç∞Ïù¥ÌÑ∞)ÏóêÏÑúÏùò ÏãúÍ∞Ñ Í∏∞Î∞ò ÏòàÏ∏°
        x_now = x[-1]
        y_time_now = time_poly(x_now)

        # - Í¥ëÍ≥†ÎπÑ Ìö®Í≥º
        y_ad = gamma * np.sqrt(budget)

        # - Ìï©ÏÇ∞
        y_total = int(y_time_now + y_ad)

        st.write(f"‚ñ∂Ô∏è ÏãúÍ∞Ñ Î™®Îç∏ ÏòàÏ∏° Ï°∞ÌöåÏàò: **{int(y_time_now):,}Ìöå**")
        st.write(f"‚ñ∂Ô∏è Í¥ëÍ≥†ÎπÑ Ìö®Í≥º Ï°∞ÌöåÏàò: **{int(y_ad):,}Ìöå**")
        st.write(f"‚ñ∂Ô∏è **ÌÜµÌï© ÏòàÏ∏° Ï°∞ÌöåÏàò:** **{y_total:,}Ìöå**")

        # 4) ÏãúÍ∞ÅÌôî
        fig, ax = plt.subplots(figsize=(8,4))
        # Ïã§Ï†ú Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞
        ax.scatter(df["timestamp"], y, color="skyblue", alpha=0.6, s=20, label="Ïã§Ï†ú Ï°∞ÌöåÏàò")

        # ÏãúÍ∞Ñ Î™®Îç∏ Í≥°ÏÑ† (Ï†ÑÏ≤¥ Íµ¨Í∞Ñ)
        ts_curve = np.linspace(0, x_now, 200)
        ax.plot(base + pd.to_timedelta(ts_curve, unit="s"),
                time_poly(ts_curve),
                color="orange", lw=2, label="ÏãúÍ∞Ñ Î™®Îç∏ Í≥°ÏÑ†")

        # ÌòÑÏû¨ ÏãúÏ†ê Ìè¨Ïù∏Ìä∏
        t_now = base + pd.to_timedelta(x_now, unit="s")
        ax.scatter(t_now, y_time_now, color="green", s=80, label="ÏãúÍ∞Ñ Î™®Îç∏ ÏòàÏ∏°Ï†ê")

        # Í¥ëÍ≥†ÎπÑ Ìö®Í≥º ÌõÑ Ï†ê
        ax.scatter(t_now, y_time_now + y_ad, color="red", s=100, label="Í¥ëÍ≥†ÎπÑ Ï†ÅÏö© ÏòàÏ∏°Ï†ê")

        # Ï∂ï ÏÑ§Ï†ï
        ax.set_xlim(df["timestamp"].min(), df["timestamp"].max() + pd.Timedelta(hours=1))
        ymin = min(y.min(), time_poly(x_now)) * 0.9
        ymax = (time_poly(x_now) + gamma*np.sqrt(budget)) * 1.1
        ax.set_ylim(ymin, ymax)

        ax.set_xlabel("ÏãúÍ∞Ñ")
        ax.set_ylabel("Ï°∞ÌöåÏàò")
        ax.legend()
        plt.xticks(rotation=45)
        st.pyplot(fig)

        if st.button("Ï†ÅÌï©ÎèÑ ÌèâÍ∞Ä"):
            # 1) MAE, RMSE Í≥ÑÏÇ∞
            y_pred_full = time_poly(x) + gamma * np.sqrt(budget)
            mae  = np.mean(np.abs(y - y_pred_full))
            rmse = np.sqrt(np.mean((y - y_pred_full)**2))
            st.write(f"**ÌèâÍ∑†Ï†àÎåÄÏò§Ï∞®(MAE):** {mae:,.2f}")

        # ‚îÄ‚îÄ 0) ÌïôÏÉù ÏùòÍ≤¨ ÏûÖÎ†•ÎûÄ Ï∂îÍ∞Ä ‚îÄ‚îÄ
        st.subheader("üí¨ Ï†ÅÌï©ÎèÑ ÌèâÍ∞Ä ÏùòÍ≤¨ ÎÇ®Í∏∞Í∏∞")
        session = st.selectbox("Ï°∞Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî", ["AÏ°∞","BÏ°∞","CÏ°∞"], key="session")

        opinion_input = st.text_area(
            "Î™®Îç∏ ÏòàÏ∏° Í≤∞Í≥ºÏôÄ Ïã§Ï†ú Ï°∞ÌöåÏàòÏùò Ï∞®Ïù¥Ïóê ÎåÄÌï¥ ÎäêÎÇÄ Ï†êÏù¥ÎÇò Í∞úÏÑ†Ìï† Ï†êÏùÑ Ï†ÅÏñ¥Ï£ºÏÑ∏Ïöî.",
            height=120,
            placeholder="Ïòà) Ï†ÄÎäî ÏòàÏ∏° Î™®Îç∏Ïù¥ ÎÑàÎ¨¥ Î≥¥ÏàòÏ†ÅÏù¥ÎùºÍ≥† ÎäêÍºàÏäµÎãàÎã§‚Ä¶"
        )

        # ÌïòÎÇòÏùò Î≤ÑÌäºÏúºÎ°ú Ï†úÏ∂ú ‚Üí ÏöîÏïΩ ‚Üí ÏãúÌä∏ Ï†ÄÏû•
        if st.button("ÏùòÍ≤¨ Ï†úÏ∂ú Î∞è ÏöîÏïΩ Ï†ÄÏû•"):
            if not opinion_input.strip():
                st.warning("Î®ºÏ†Ä ÏùòÍ≤¨ÏùÑ ÏûÖÎ†•Ìï¥ Ï£ºÏÑ∏Ïöî.")
            else:
                # 1) GPT ÏöîÏïΩ
                prompt = (
                    "Îã§Ïùå ÌïôÏÉù ÏùòÍ≤¨ÏùÑ Í∞ÑÍ≤∞ÌïòÍ≤å ÏöîÏïΩÌï¥ Ï£ºÏÑ∏Ïöî:\n\n"
                    f"{opinion_input}"
                )
                resp = openai.chat.completions.create(
                    model="gpt-3.5-turbo",
                    messages=[
                        {"role": "system", "content": "ÎãπÏã†ÏùÄ ÏàòÏóÖ ÌÜ†Ïùò ÎÇ¥Ïö©ÏùÑ Í∞ÑÍ≤∞Ìûà ÏöîÏïΩÌïòÎäî AIÏûÖÎãàÎã§."},
                        {"role": "user",   "content": prompt}
                    ]
                )
                summary = resp.choices[0].message.content
                st.markdown("**ÏöîÏïΩ:**  " + summary)

                # 2) Ïä§ÌîÑÎ†àÎìúÏãúÌä∏Ïóê Í∏∞Î°ù
                ss = gc.open_by_key(yt_conf["spreadsheet_id"])
                ws = ss.worksheet("Ï†ÅÌï©ÎèÑÌèâÍ∞Ä")  # ÏãúÌä∏ Ïù¥Î¶Ñ ÌôïÏù∏
                timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
                # [ÏÑ∏ÏÖò, ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ, ÏõêÎ¨∏ ÏùòÍ≤¨, ÏöîÏïΩ]
                ws.append_row([session, timestamp, opinion_input, summary])

                st.success("ÏùòÍ≤¨Í≥º ÏöîÏïΩÏù¥ ÏãúÌä∏Ïóê Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!")

    elif step==4:
        st.header("4Ô∏è‚É£ ÌÜ†Ïùò ÎÇ¥Ïö© ÏûÖÎ†• & ÏöîÏïΩÌïòÍ∏∞")

        # 4Ï∞®Ïãú ÏÑ∏ÏÖò Íµ¨Î∂Ñ (Ïòà: AÏ°∞, BÏ°∞ Îì±)
        session = st.selectbox("Ï°∞Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî", ["AÏ°∞","BÏ°∞","CÏ°∞"], key="session")

        # ÌÜ†Ïùò ÎÇ¥Ïö© ÏûÖÎ†•
        raw = st.text_area("ÌÜ†Ïùò ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî", key="discussion_raw", height=200)

        if st.button("ÏöîÏïΩ & Ï†ÄÏû•"):
            if not raw.strip():
                st.error("ÌÜ†Ïùò ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥Ïïº Ìï©ÎãàÎã§.")
                return
            with st.spinner("GPTÏóêÍ≤å ÏöîÏïΩÏùÑ Î∂ÄÌÉÅÌïòÎäî Ï§ë..."):
                summary = summarize_discussion(raw)
            st.success("ÏöîÏïΩ ÏôÑÎ£å!")
            st.write("**ÏöîÏïΩÎ≥∏**")
            st.write(summary)

            # Ïä§ÌîÑÎ†àÎìúÏãúÌä∏ Í∏∞Î°ù
            ss = gc.open_by_key(yt_conf["spreadsheet_id"])
            ds = ss.worksheet("ÌÜ†ÏùòÏöîÏïΩ")  # ÎØ∏Î¶¨ ÎßåÎì§Ïñ¥ÎëêÏÑ∏Ïöî
            timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
            ds.append_row([session, timestamp, raw, summary])
            st.info("Ïä§ÌîÑÎ†àÎìúÏãúÌä∏Ïóê Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.")

# === Î©îÏù∏ ÌÉ≠ Íµ¨Ï°∞ ===
tab1, tab2 = st.tabs(["Î°úÍ∑∏Ïù∏", "ÌöåÏõêÍ∞ÄÏûÖ"])
with tab1:
    if not st.session_state["logged_in"]:
        login_ui()
    else:
        main_ui()
with tab2:
    if not st.session_state["logged_in"]:
        signup_ui()
    else:
        st.info("Ïù¥ÎØ∏ Î°úÍ∑∏Ïù∏Îêú ÏÉÅÌÉúÏûÖÎãàÎã§.")

if "history" not in st.session_state:
    st.session_state["history"] = []

st.sidebar.markdown("## üó®Ô∏è AI Ï±óÎ¥á")
with st.sidebar.form("chat_form", clear_on_submit=True):
    chat_input = st.text_input("ÏßàÎ¨∏ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî", key="chat_input")
    submitted = st.form_submit_button("Ï†ÑÏÜ°")

if submitted:
    # 2) API Ìò∏Ï∂ú
    messages = [{"role":"system","content":"ÎãπÏã†ÏùÄ ÏπúÏ†àÌïú ÏàòÌïô ÌäúÌÑ∞ÏûÖÎãàÎã§."}]
    # ÎåÄÌôî ÌûàÏä§ÌÜ†Î¶¨ÎèÑ Ìè¨Ìï®ÏãúÌÇ§Î†§Î©¥:
    for role, msg in st.session_state["history"]:
        messages.append({
                "role":"user" if role=="üßë‚Äçüéì" else "assistant", 
                "content":msg
        })
    messages.append({"role":"user","content": chat_input})

    res = openai.chat.completions.create(
        model="gpt-3.5-turbo", messages=messages
    )
    answer = res.choices[0].message.content

    # 3) ÌûàÏä§ÌÜ†Î¶¨Ïóê Ï∂îÍ∞Ä
    st.session_state["history"].append(("üßë‚Äçüéì", chat_input))
    st.session_state["history"].append(("ü§ñ", answer))

    # 5) ÎåÄÌôî ÎÇ¥Ïö© Î≥¥Ïó¨Ï£ºÍ∏∞
    if st.session_state["history"]:
        for role, msg in st.session_state["history"][-1:]:
            st.sidebar.markdown(f"**{role}:** {msg}")

    with st.expander("Ïù¥Ï†Ñ ÎåÄÌôî Í∏∞Î°ù Î≥¥Í∏∞"):
        if len(st.session_state["history"]) > 1:
            for role, msg in st.session_state["history"][:-1]:
                st.markdown(f"**{role}:** {msg}")
        else:
            st.markdown("Ïù¥Ï†Ñ ÎåÄÌôî ÎÇ¥Ïó≠Ïù¥ ÏóÜÏäµÎãàÎã§.")